[数学题](https://codeforces.com/contest/1744/problem/D)

> 写完了一看其实挺简单的，但是在写的时候cpu烧了好几次，

2^n本质上就是n个2相乘，所以我们只需要找到在整个序列中的数字能提供多少个2,

注意，‘提供多少个2’这句话有一定条件，

1.n%2==0: n能被2整除，提供一个2，这样就可以把该数字拆成(n//2)*2

如果我们将数组中的每个数字都拆开，就可以得到：2*(n1//2)*2*(n2//2)...

等价于2*2*2*2...*(n1//2)*(n2//2)... === 2^x*C(后面的积)

因为一些数字可以被2*2整除，或2*2*2，我们需要把他们拆为最小单位，那么我们可以写出如下代码，将4，8，32，64，这样的2^n*x的数字拆成2*2*2...*x的格式

```python
        if i%2==0:
            op=2
            while i% op ==0:
                p+=1#p是提供多少个2
                op*=2
        return p
```

这段代码是本题最重要的拆分部分，

这样我们可以计算出原数组所共享出2的数量

if (n<=p) cout << 0  << endl;直接出答案

然后我们可以找到need=n-p，我们还需要通过操作所添加的2的数量；

对于本题的所有索引值：1---n;

我们可以通过从2循环来找到所有可能贡献值，因为我们要最小化操作次数，那么我们对所有可能贡献值进行排序；

```python
        ans=0
        g=[]
        for i in range(n,0,-1):
            if i %2==0:#可贡献2
                can=0#记录共享数
                op=2
                while i%op==0:
                    can+=1
                    op*=2
                g.append(can)
        g.sort(reverse=True)#从大到小排序
        for i in g:
            need-=i
            ans+=1
            if need<=0:
                break
```

最后判断一些need>0就行了。

